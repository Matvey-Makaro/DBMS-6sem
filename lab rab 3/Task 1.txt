SELECT TABLE_NAME, OWNER FROM DBA_TABLES WHERE OWNER = 'PROD' or OWNER = 'DEV';

SELECT TABLE_NAME, OWNER, COLUMN_NAME, DATA_TYPE, DATA_DEFAULT FROM ALL_TAB_COLUMNS WHERE OWNER = 'PROD' or OWNER = 'DEV';

SELECT OBJECT_NAME, OWNER, OBJECT_TYPE, CREATED FROM ALL_OBJECTS WHERE OWNER = 'PROD' or OWNER = 'DEV';

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, R_OWNER, R_CONSTRAINT_NAME, TABLE_NAME FROM ALL_CONSTRAINTS WHERE OWNER = 'DEV';

SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY FROM ALL_SEQUENCES WHERE SEQUENCE_OWNER = 'DEV';

CREATE OR REPLACE FUNCTION is_table_exists(schema_name IN VARCHAR2, tab_name IN VARCHAR2) RETURN BOOLEAN
IS
    num NUMBER;
BEGIN
    SELECT DISTINCT COUNT(TABLE_NAME) INTO num FROM DBA_TABLES WHERE OWNER = UPPER(schema_name) AND TABLE_NAME = UPPER(tab_name);
    IF num > 0 THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN FALSE;
    WHEN OTHERS THEN
        RETURN FALSE;
END is_table_exists;

SELECT is_table_exists('DEV', 'MYDEVTABLE') FROM dual;


CREATE OR REPLACE FUNCTION get_inline_constraint_description(schema_name IN VARCHAR2, tab_name IN VARCHAR2, col_name IN VARCHAR2) RETURN VARCHAR2
IS
CURSOR cur_get_inl_constraint IS
SELECT * FROM
((SELECT CONSTRAINT_NAME FROM ALL_CONS_COLUMNS
WHERE OWNER = UPPER(schema_name) AND TABLE_NAME = UPPER(tab_name) AND COLUMN_NAME = UPPER(col_name)) left
INNER JOIN
(SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, SEARCH_CONDITION FROM DBA_CONSTRAINTS
WHERE OWNER = UPPER(schema_name) AND TABLE_NAME = UPPER(tab_name) AND GENERATED = 'GENERATED NAME') right
ON left.CONSTRAINT_NAME = right.CONSTRAINT_NAME);
constr_description VARCHAR2(300);
BEGIN
    FOR rec IN  cur_get_inl_constraint LOOP
        CASE rec.CONSTRAINT_TYPE
            WHEN 'P' THEN constr_description := constr_description || ' PRIMARY KEY';
            WHEN 'U' THEN constr_description := constr_description ||' UNIQUE';
            WHEN 'C' THEN
                IF rec.SEARCH_CONDITION NOT LIKE '% IS NOT NULL' THEN
                    constr_description := constr_description || ' CHECK(' || rec.SEARCH_CONDITION || ')';
                END IF;
            ELSE NULL;
        END CASE;
    END LOOP;
RETURN constr_description;
END get_inline_constraint_description;


CREATE OR REPLACE FUNCTION get_sequence_description(schema_name IN VARCHAR2, seq_name IN VARCHAR2) RETURN VARCHAR2
IS
min_val NUMBER;
max_val NUMBER;
inc_by NUMBER;
gen_type VARCHAR2(10);
seq_description VARCHAR2(300);
BEGIN
    SELECT MIN_VALUE, MAX_VALUE, INCREMENT_BY INTO min_val, max_val, inc_by FROM ALL_SEQUENCES WHERE SEQUENCE_NAME = seq_name AND SEQUENCE_OWNER = UPPER(schema_name);
    SELECT GENERATION_TYPE INTO gen_type FROM ALL_TAB_IDENTITY_COLS WHERE SEQUENCE_NAME = seq_name AND OWNER = UPPER(schema_name);
    -- It makes no difference how to do this or the following.
    -- seq_description := 'GENERATED ' || gen_type || ' AS IDENTITY' || ' START WITH ' || min_val || ' INCREMENT BY ' || inc_by || ' MAXVALUE ' || max_val;

    seq_description := 'GENERATED ' || gen_type || ' AS IDENTITY';
    IF min_val != 1 THEN
        seq_description := seq_description || ' START WITH ' || min_val;
    END IF;
    IF inc_by != 1 THEN
        seq_description := seq_description || ' INCREMENT BY ' || inc_by;
    END IF;
    IF max_val != 999999999999999999999999999 THEN
        seq_description := seq_description || ' MAXVALUE ' || max_val;
    END IF;
    RETURN seq_description;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        BEGIN
            DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND in get_sequence_description()');
            RETURN NULL;
        END;
    WHEN OTHERS THEN
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Unknown error in get_sequence_description()');
            RETURN NULL;    
        END;
END get_sequence_description;


CREATE OR REPLACE FUNCTION get_col_description(schema_name IN VARCHAR2, tab_name IN VARCHAR2, col_name IN VARCHAR2) RETURN VARCHAR2
IS
CURSOR cur_get_col IS
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, NULLABLE, DATA_DEFAULT
FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER(schema_name) AND TABLE_NAME = UPPER(tab_name) AND COLUMN_NAME = UPPER(col_name);
col_description VARCHAR2(500) := '';
BEGIN

FOR rec IN cur_get_col LOOP
    col_description := rec.COLUMN_NAME || ' ' || rec.DATA_TYPE;

    IF rec.NULLABLE = 'N' THEN
        col_description := col_description || ' NOT NULL';
    END IF;
    
    col_description := col_description || get_inline_constraint_description(schema_name, tab_name, col_name);

    IF rec.DATA_DEFAULT IS NOT NULL THEN
        BEGIN
            IF rec.DATA_DEFAULT LIKE '%.nextval' THEN
                col_description -- TODO: дообавить sequence
            ELSE
                col_description := col_description || ' DEFAULT ' || rec.DATA_DEFAULT;
            END IF
        END;
    END IF;
END LOOP;
RETURN col_description;
END get_col_description;


CREATE OR REPLACE PROCEDURE cmp_table_structure(dev_schema_name IN VARCHAR2, prod_schema_name IN VARCHAR2, tab_name IN VARCHAR2)
IS
CURSOR cur_get_columns IS
SELECT * FROM
((SELECT COLUMN_NAME dev_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER(dev_schema_name) AND TABLE_NAME = UPPER(tab_name)) dev
FULL OUTER JOIN
(SELECT COLUMN_NAME prod_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER(prod_schema_name) AND TABLE_NAME = UPPER(tab_name)) prod 
ON dev.dev_col_name = prod.prod_col_name);
BEGIN
FOR rec IN cur_get_columns LOOP
    IF rec.dev_col_name IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('ALTER TABLE ' || tab_name || ' DROP COLUMN ' || rec.prod_col_name || ';');
    ELSIF rec.prod_col_name IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('ALTER TABLE ' || tab_name || 'ADD COLUMN ' || rec.dev_col_name || ';') -- TODO: Добавить получение определение колонки
    END IF;
END LOOP;

END cmp_table_structure;


CREATE OR REPLACE PROCEDURE cmp_schemes(dev_schema_name IN VARCHAR2, prod_schema_name IN VARCHAR2)
IS
    CURSOR get_table_name IS
    SELECT TABLE_NAME FROM DBA_TABLES
    WHERE OWNER = UPPER(dev_schema_name);
    --TYPE varchar2_arr IS TABLE OF DBA_TABLES.TABLE_NAME%TYPE;
    --varchar2_arr names_to_add := varchar2_arr();
BEGIN
    FOR table_name IN get_table_name LOOP
        IF NOT is_table_exists(prod_schema_name, table_name.TABLE_NAME) THEN
            DBMS_OUTPUT.PUT_LINE('Add table ' || table_name.TABLE_NAME);
            CONTINUE;
        END IF;


    END LOOP;
END cmp_schemes;

exec cmp_schemes('DEV', 'PROD');


SELECT * FROM ((SELECT TABLE_NAME dev_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER('DEV') AND TABLE_NAME = UPPER('MYTABLE')) dev
FULL OUTER JOIN
(SELECT TABLE_NAME prod_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER('PROD') AND TABLE_NAME = UPPER('MYTABLE')) prod 
ON dev.dev_col_name = prod.prod_col_name);

SELECT * FROM ((SELECT COLUMN_NAME dev_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER('DEV') AND TABLE_NAME = UPPER('MYTABLE')) dev
FULL OUTER JOIN
(SELECT COLUMN_NAME prod_col_name FROM ALL_TAB_COLUMNS
WHERE OWNER = UPPER('PROD') AND TABLE_NAME = UPPER('MYTABLE')) prod 
ON dev.dev_col_name = prod.prod_col_name);
